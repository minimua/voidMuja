# 索引

#### 1.  **为什么索引能提高查询速度?**

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**

索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

#### 2.  聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?
-   InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；
-   MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**
在 MySQL 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**聚集索引的优点**
聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

**聚集索引的缺点**
1.  **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2.  **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

**非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。**
非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

**非聚集索引的优点**
**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

**非聚集索引的缺点**
1.  跟聚集索引一样，非聚集索引也依赖于有序的数据
2.  **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

```md
聚簇索引就是数据和索引放在一起，b+树的叶子节点上存储了索引和对应的数据，比如InnoDB索引文件的.ibd文件中就包含了该表的索引和数据；
非聚簇索引就是索引和数据是分开存放的，b+树的叶子节点上存储的是索引和对应的这条数据的内存地址，查询的时候会根据这个内存地址再去获取整行数据，比如MyISAM的.MYD存的是数据 .MYI存的是索引；

表里只能存在一个聚簇索引，非聚簇索引可以有多个，非聚簇索引上存的是这个索引字段和对应的聚簇索引的key，比如有一个给table，里面有id是聚簇索引，name是非聚簇索引，还有一些其他的age，sex属性，当根据name去查询这整条数据的时候，会先根据name这个索引，查到这条数据的id，再根据id查到这条数据，就是走了2个b+树，这就是回表，但是如果只是根据name去查询name和id两个属性，就只需要查询一次就够了，就不会回表。
```

#### 3.  索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗?)
第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

#### 4.  **索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析**
https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg
Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。因为哈希表的特点就是**可以快速的精确查询，但是不支持范围查询**

B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于**非叶子节点是否存储数据**的问题

Hash不支持范围查询，二叉树树高很高，只有B树跟B+有的一比。B树一个节点可以存储多个元素，相对于完全平衡二叉树整体的树高降低了，磁盘IO效率提高了。而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是**为了提高范围查找的效率**。提高了的原因也无非是会有指针指向下一个节点的叶子节点。Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。


#### 5.  B+树做索引比红黑树好在哪里？

红黑树和平衡二叉树有相同缺点，每个节点存储一个关键词，数据量大时，导致红黑树的深度很深，mysql每次读取时消耗大量io
B+树的数据都会浓郁存储在叶子结点，而且叶子结点之间都有指针指向，这会提高范围查询的效率。  所以B+树才是最适合做查询索引的树结构。

#### 6.  **最左前缀匹配原则了解么？**

使用联合索引的时候，最左边的优先
只有左边的确定了，右边的才是有序的



#### 7.  什么是覆盖索引
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。**

#### 8.索引失效
-   当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效；   
-   当我们在查询条件中对索引列使用函数，就会导致索引失效。    
-   当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。    
-   MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。    
-   联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。    
-   在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。